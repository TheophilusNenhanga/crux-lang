struct Point { x, y }

// Function parameters and return values
struct MathOps {
    apply_operation
}

let math_ops = MathOps {
    apply_operation: fn(operation, a, b) {
        return operation(a, b);
    }
};

let add_func = fn(x, y) { return x + y; };
let result = math_ops.apply_operation(add_func, 10, 5);
assert(result == 15, "Failed passing function as parameter to struct function");

// Array of structs
let points = [
    Point { x: 0, y: 0 },
    Point { x: 1, y: 1 },
    Point { x: 2, y: 2 }
];

assert(points[1].x == 1 and points[1].y == 1, "Failed array of struct instances");

// Struct with mixed field types
struct Mixed {
    number_field,
    string_field,
    boolean_field,
    function_field,
    struct_field
}

let mixed = Mixed {
    number_field: 42,
    string_field: "test",
    boolean_field: true,
    function_field: fn() { return "function result"; },
    struct_field: Point { x: 5, y: 10 }
};

assert(mixed.number_field == 42, "Failed mixed struct - number field");
assert(mixed.string_field == "test", "Failed mixed struct - string field");
assert(mixed.boolean_field == true, "Failed mixed struct - boolean field");
assert(mixed.function_field() == "function result", "Failed mixed struct - function field");
assert(mixed.struct_field.x == 5, "Failed mixed struct - nested struct field");

// Function field with multiple parameters
struct Formatter {
    format_name
}

let formatter = Formatter {
    format_name: fn(first, last, title) {
        return title + " " + first + " " + last;
    }
};

assert(formatter.format_name("John", "Doe", "Mr.") == "Mr. John Doe", "Failed function field with multiple parameters");

// Recursive struct references (if supported)
struct Node {
    value,
    next
}

let node1 = Node { value: 1, next: nil };
let node2 = Node { value: 2, next: node1 };

assert(node2.next.value == 1, "Failed recursive struct reference");

// Function field that modifies struct state
struct StatefulCounter {
    count,
    increment,
    reset,
    get_count
}

let stateful = StatefulCounter {
    count: 0,
    increment: fn() { stateful.count = stateful.count + 1; },
    reset: fn() { stateful.count = 0; },
    get_count: fn() { return stateful.count; }
};

stateful.increment();
stateful.increment();
assert(stateful.get_count() == 2, "Failed stateful function increment");
stateful.reset();
assert(stateful.get_count() == 0, "Failed stateful function reset");

println("=== END OF TESTING STRUCTS ===");